"""
Get VirusTotal reports.
"""

from argparse import ArgumentParser
from datetime import datetime
from functools import partial
import hashlib
from pathlib import Path
from pprint import pprint
import subprocess
import sys
import time
from typing import Generator, Iterable, Optional

import requests
from tqdm import tqdm

from cfg import KEY
from utils import get_file_hash


URL = "https://www.virustotal.com/api/v3/files/"
HEADERS = {"accept": "application/json", "x-apikey": KEY}
QUOTA_EXCEEDED_ERROR = 429
SUCCESS = 200
TIMEOUT = 60


class ErrorStream:
    def __init__(self, file: Path) -> None:
        self.file = file

    def write(self, message: str):
        with open(self.file, "a") as log_file:
            log_file.write(message)


ERRORS = ErrorStream("err.log")


def wait_until_midnight():
    current = datetime.utcnow()
    midnight = datetime(current.year, current.month, current.day, 0, 0, 0)
    seconds = abs((midnight - current).total_seconds())

    with tqdm(total=int(seconds), unit="s") as pbar:
        print(f"{current=}, {midnight=}, wait={seconds}")
        while seconds > 0:
            time.sleep(1)
            seconds -= 1
            pbar.update(1)
    time.sleep(1)
    print(f"\nIt's now {str(midnight.time())} UTC. Done waiting!")


def count_lines_in_file(file: Path) -> int:
    result = subprocess.run(
        ["wc", "-l", file.as_posix()],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )
    if result.returncode == 0:
        output = result.stdout.strip()
        line_count = int(output.split()[0])
        return line_count
    else:
        print("Error:", result.stderr)
        return None


def sorel_file_of_inputs_to_input(meta_csv: Path) -> Generator[str, None, None]:
    with open(meta_csv, "r") as fp:
        for i, line in enumerate(fp):
            if i == 0:
                continue
            line = line.strip().split(",")
            if int(line[1]) == 0: # is_malware field
                continue
            elif int(line[1]) == 1:  # sha256 field
                yield line[0]
            else:
                raise RuntimeError()


def file_of_inputs_to_input(
    file: Path,
    skip_first_line: bool = False,
    csv_col_idx: int = 0,
) -> Generator[str, None, None]:
    with open(file, "r") as fp:
        for i, line in enumerate(fp):
            if i == 0 and skip_first_line:
                continue
            line = line.strip().split(",")
            yield line[csv_col_idx]


def query_virustotal(url: str) -> requests.Response:
    try:
        response = requests.get(url, headers=HEADERS, timeout=TIMEOUT)
        return response
    except requests.exceptions.Timeout:
        return None


def get_reports_from_hashes(hashes: list[str]) -> str:
    for h in hashes:
        url = URL + h

        if (response := query_virustotal(url)) is None:
            print(f"Timeout: {h}", file=ERRORS)
            yield None
            continue

        if response.status_code == QUOTA_EXCEEDED_ERROR:
            print("Waiting")
            wait_until_midnight()
            if (response := query_virustotal(url)) is None:
                print(f"Timeout: {h}", file=ERRORS)
                yield None
                continue

        if int(response.status_code) == SUCCESS:
            yield response.text
            continue

        print(f"HTTPError: {h} {response.status_code}", file=ERRORS)
        yield None
        continue


def main(hashes: list[str], outdir: Path, total: Optional[int] = None) -> None:
    i = 0
    for h, r in tqdm(zip(hashes, get_reports_from_hashes(hashes)), total=total):
        if r is None:
            continue
        with open((outdir / h).with_suffix(".json"), "w") as fp:
            fp.write(r)
        i += 1


def cli() -> None:
    parser = ArgumentParser()
    parser.add_argument("--file_or_hash_mode", choices=["file", "hash"], required=True)
    parser.add_argument("--outdir", type=Path, required=True)
    parser.add_argument("--input", type=str, required=False)
    parser.add_argument("--file_of_inputs", type=Path, required=False)
    parser.add_argument("--directory", type=Path, required=False)
    parser.add_argument("--ignore_complete", action="store_true")
    parser.add_argument("--mode", choices=["sha256", "md5", "sha1"], default="sha256")
    parser.add_argument("--sorel", action="store_true") 
    args = parser.parse_args()

    if list(map(bool, [args.input, args.file_of_inputs, args.directory])).count(True) != 1:
        raise ValueError("Only one input type allowed/required.")

    if args.input:
        inputs = [args.input]
        total = 1
    elif args.file_of_inputs:
        total = count_lines_in_file(args.file_of_inputs)
        if args.sorel:
            inputs = sorel_file_of_inputs_to_input(args.file_of_inputs)
            total -= 1
        else:
            inputs = file_of_inputs_to_input(
                args.file_of_inputs, args.file_of_inputs.suffix == ".csv"
            )
    elif args.directory:
        inputs = args.directory.iterdir()
        total = sum(1 for _ in args.directory.iterdir())
    else:
        raise ValueError("No files to scan")

    if args.file_or_hash_mode == "file":
        inputs = map(Path, inputs)
        hashes = map(partial(get_file_hash, args.mode), inputs)
    else:
        hashes = inputs

    if args.ignore_complete:
        hashes = filter(lambda h: not (args.outdir / h).with_suffix(".json").exists(), hashes)
        total -= sum(1 for _ in args.outdir.iterdir())

    main(hashes, args.outdir, total)


if __name__ == "__main__":
    cli()
