"""
Search for files.
"""

import argparse
import hashlib
from copy import deepcopy
import multiprocessing
import os
from pathlib import Path
import platform
from pprint import pprint
import re
import subprocess
import shutil
import sys
from typing import Any, Callable, ClassVar
import warnings

from tqdm import tqdm


def rmdir_r(path: Path):
    if not path.is_dir():
        return
    for p in path.iterdir():
        rmdir_r(p)
    path.rmdir()


def flatten_directory(directory):
    for root, _, files in os.walk(directory):
        for file in files:
            source_path = os.path.join(root, file)
            destination_path = os.path.join(directory, file)
            shutil.move(source_path, destination_path)


class GetSearchDirs:
    def __call__(self) -> list[Path]:
        if platform.system() == "Windows":
            search = self.pe_dirs()
        elif platform.system() == "Linux":
            search = self.elf_dirs()
        elif platform.system() == "Darwin":
            search = self.macho_dirs()
        else:
            raise RuntimeError()

        dirs = []
        for d in search:
            try:
                d.exists()
                dirs.append(d)
            except PermissionError:
                pass

        return sorted(dirs)

    @staticmethod
    def _unix_like_helper() -> tuple[list[Path], list[Path], list[Path]]:
        dirs = [Path(p) for p in ["bin", "lib", "lib32", "libx32", "lib64", "opt", "sbin"]]
        intermediate = [Path(p) for p in ["", ".local", "local"]]
        mounts = [Path(p) for p in ["/", "/boot", "/root", "/usr", "/var", "home/lk3591"]]
        return dirs, intermediate, mounts

    @staticmethod
    def elf_dirs() -> list[Path]:
        dirs, intermediate, mounts = GetSearchDirs._unix_like_helper()
        search = [m / l / p for p in dirs for l in intermediate for m in mounts]
        return search

    @staticmethod
    def macho_dirs() -> list[Path]:
        dirs, intermediate, mounts = GetSearchDirs._unix_like_helper()
        search = [m / l / p for p in dirs for l in intermediate for m in mounts]
        search += list(Path("/Applications").iterdir())
        return search

    @staticmethod
    def pe_dirs() -> list[Path]:
        ...


class IsFile:
    def __call__(self, file: Path) -> bool:
        if platform.system() == "Windows":
            return self.is_pe_file(file)
        if platform.system() == "Linux":
            return self.is_elf_file(file)
        if platform.system() == "Darwin":
            return self.is_macho_file(file)
        raise RuntimeError()

    @staticmethod
    def is_elf_file(file: Path) -> bool:
        try:
            output = subprocess.check_output(["sudo", "file", str(file)])
            decoded_output = output.decode("utf-8", errors="replace")
            return "ELF" in decoded_output
        except subprocess.CalledProcessError:
            return False

    @staticmethod
    def is_macho_file(file: Path) -> bool:
        try:
            output = subprocess.check_output(["sudo", "file", str(file)])
            decoded_output = output.decode("utf-8", errors="replace")
            return "Mach-O" in decoded_output
        except subprocess.CalledProcessError:
            return False

    @staticmethod
    def is_pe_file(file: Path) -> bool:
        ...


class FileType:
    MACHO: ClassVar[list[str]] = [
        "BUNDLE",
        "EXECUTE",
        "DYLIB",
        "OBJECT",
        "PRELOAD",
        "DUMP",
        "DYLINKER",
        "DSYMINFO",
        "KEXTBUNDLE",
        "DSYM",
    ]
    ELF: ClassVar[list[str]] = ["DYN", "REL", "EXEC", "CORE"]

    def __call__(self, file: Path) -> Any:
        if platform.system() == "Windows":
            return self.pe_file_type(file)
        if platform.system() == "Linux":
            return self.elf_file_type(file)
        if platform.system() == "Darwin":
            return self.macho_file_type(file)
        raise RuntimeError()

    @staticmethod
    def macho_file_type(file: Path) -> str:
        try:
            output = subprocess.check_output(["sudo", "otool", "-hv", file.as_posix()])
            output = output.decode("utf-8", errors="replace")
            types = []
            for t in FileType.MACHO:
                if t in output:
                    types.append(t)
            if len(types) == 1:
                return types[0]
            if len(types) > 1:
                warnings.warn(f"Multiple types detected: {types} for {file.name}")
            if len(types) == 0:
                warnings.warn(f"No type detected for {file.name}")
            return None

        except subprocess.CalledProcessError:
            return None

    @staticmethod
    def elf_file_type(file: Path) -> str:
        try:
            output = subprocess.check_output(["sudo", "readelf", "-h", file.as_posix()])
            output = output.decode("utf-8", errors="replace")
            type_line = [line for line in output.split("\n") if "Type:" in line][0]
            types = []
            for t in FileType.ELF:
                if t in type_line:
                    types.append(t)
            if len(types) == 1:
                return types[0]
            if len(types) > 1:
                warnings.warn(f"Multiple types detected: {types} for {file.name}")
            if len(types) == 0:
                warnings.warn(f"No type detected for {file.name}")
            return None

        except subprocess.CalledProcessError:
            return None

    @staticmethod
    def pe_file_type(file: Path) -> str:
        ...


class Search:
    """Search for files matching the specified criteria in a directory."""

    def __init__(
        self, is_file_fn: IsFile, directories: list[Path], outfile: str, num_processes: int
    ) -> None:
        self.is_file_fn = is_file_fn
        self.directories = directories
        self.outfile = outfile
        self.num_processes = num_processes

    def __call__(self):
        pool = multiprocessing.Pool(processes=self.num_processes)
        progress_bar = tqdm(total=len(self.directories))
        for directory in self.directories:
            pool.apply_async(
                self.search_directory_and_write,
                args=(directory, self.is_file_fn, self.outfile),
                callback=lambda _: progress_bar.update(1),
            )
        pool.close()
        pool.join()
        progress_bar.close()

    @staticmethod
    def search_directory_and_write(
        directory: Path, criteria_func: Callable[[Path], bool], outfile: str
    ) -> None:
        try:
            if directory.exists() and directory.is_dir():
                matching_files = Search.find_files_with_criteria(directory, criteria_func)
                with open(outfile, "a") as file:
                    for file_path in matching_files:
                        file.write(str(file_path) + "\n")
            else:
                print(f"Directory does not exist: {directory}")
        except Exception as e:
            print(f"Error in {directory}: {e}")

    @staticmethod
    def find_files_with_criteria(
        directory: Path, criteria_func: Callable[[Path], bool]
    ) -> list[Path]:
        matching_files = []
        try:
            for item in directory.iterdir():
                if item.is_file() and criteria_func(item):
                    matching_files.append(item)
                elif item.is_dir():
                    matching_files.extend(Search.find_files_with_criteria(item, criteria_func))
        except PermissionError as err:
            print(f"Permission error in {directory}: {err}")
        return matching_files


class Copy:
    def __init__(self, files: list[Path], destination_directory: Path) -> None:
        self.files = files
        self.destination_directory = destination_directory

    def __call__(self):
        for source_path in tqdm(self.files):
            source_path = Path(source_path)
            if source_path.exists():
                relative_path = source_path.relative_to("/")
                destination_path = self.destination_directory / relative_path
                destination_path.parent.mkdir(mode=0o777, parents=True, exist_ok=True)

                if not destination_path.exists():
                    try:
                        shutil.copy2(source_path, destination_path)
                    except PermissionError:
                        pass


def sha_rename(destination_directory: Path) -> None:
    for f in tqdm(list(destination_directory.rglob("*"))):
        if f.is_file():
            v = hashlib.sha256(f.read_bytes()).hexdigest()
            f_new = (f.parent / str(v)).with_suffix(f.suffix)
            f.rename(f_new)


def clean_output_dir(destination_directory: Path) -> None:
    flatten_directory(destination_directory)
    for p in destination_directory.iterdir():
        if p.is_dir():
            rmdir_r(p)


def ext_rename(files: list[Path], file_type_fn: FileType, remove: bool = False) -> None:
    for f in tqdm(files):
        ext = file_type_fn(f)
        if ext is None and remove:
            f.unlink()
        else:
            f.rename(f.with_suffix(f".{ext}"))


parser = argparse.ArgumentParser(
    description="Search for and copy files matching specified criteria."
)
parser.add_argument("--search", action="store_true", help="Perform the search process")
parser.add_argument("--copy", action="store_true", help="Perform the copy process")
parser.add_argument(
    "--sha_rename", action="store_true", help="Rename copied files based on SHA-256 hash"
)
parser.add_argument(
    "--ext_rename", action="store_true", help="Rename copied files based thier file type"
)
parser.add_argument("--remove", action="store_true", help="Remove files with uncertain extensions.")
args = parser.parse_args()

OUTPUT_FILE = Path(f"{platform.system()}.txt")
DESTINIATION_DIRECTORY = Path(f"{platform.system()}")

if args.search:
    print("Searching...")
    Search(IsFile(), GetSearchDirs()(), OUTPUT_FILE, multiprocessing.cpu_count())()

if args.copy:
    print("Copying...")
    Copy([Path(f) for f in OUTPUT_FILE.read_text().split("\n")], DESTINIATION_DIRECTORY)

if args.sha_rename:
    print("Renaming...")
    sha_rename(DESTINIATION_DIRECTORY)
    clean_output_dir(DESTINIATION_DIRECTORY)

if args.ext_rename:
    ext_rename(sorted([f for f in DESTINIATION_DIRECTORY.iterdir()]), FileType(), args.remove)
